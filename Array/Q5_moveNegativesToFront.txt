ğŸš€ Move All Negative Numbers to the Beginning and Positive to the End



âœ… Brute Force Solution (Using Extra Space)
Approach:
ğŸ—‚ï¸ Create two separate arrays:

One for negative numbers.

One for positive numbers.

ğŸ” Traverse the original array and divide elements into these arrays.

ğŸ”„ Combine the arrays, with negative numbers at the front and positive numbers at the end.

Code Implementation (Java):
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        int[] arr = {-12, 11, -13, 5, -6, -7, 5, 11};
        moveNegativesToFront(arr);
        
        // Print the array after reordering
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }

    public static void moveNegativesToFront(int[] arr) {
        int[] negative = new int[arr.length];
        int[] positive = new int[arr.length];
        int negCount = 0, posCount = 0;

        // Populate negative and positive arrays
        for (int num : arr) {
            if (num < 0) {
                negative[negCount++] = num;
            } else {
                positive[posCount++] = num;
            }
        }

        // Copy the negative numbers to the front
        for (int i = 0; i < negCount; i++) {
            arr[i] = negative[i];
        }
        
        // Copy the positive numbers to the end
        for (int i = 0; i < posCount; i++) {
            arr[negCount + i] = positive[i];
        }
    }
}
Complexity:
â±ï¸ Time Complexity: O(n)

ğŸ§‘â€ğŸ’» Space Complexity: O(n) (due to extra arrays)



âœ… Efficient Solution (Two Pointer Approach)
Approach:
ğŸ§­ Two pointers technique:

low starts at the beginning of the array.

high starts at the end of the array.

ğŸƒâ€â™‚ï¸ Move the pointers:

Increment low when a negative number is found.

Decrement high when a positive number is found.

ğŸ”„ Swap if arr[low] is positive and arr[high] is negative.

Repeat until the low pointer crosses the high pointer.

Code Implementation (Java):
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        int[] arr = {-12, 11, -13, 5, -6, -7, 5, 11};
        moveNegativesToFront(arr);
        
        // Print the array after reordering
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }

    public static void moveNegativesToFront(int[] arr) {
        int low = 0, high = arr.length - 1;

        // Traverse the array with two pointers
        while (low < high) {
            if (arr[low] < 0) {
                low++;  // Move the low pointer if it is already negative
            } else if (arr[high] >= 0) {
                high--;  // Move the high pointer if it is positive
            } else {
                // Swap the elements when the left is positive and right is negative
                swap(arr, low, high);
                low++;
                high--;
            }
        }
    }

    // Helper method to swap elements at indices i and j
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
Complexity:
â±ï¸ Time Complexity: O(n)

ğŸ§‘â€ğŸ’» Space Complexity: O(1) (no extra space used)

ğŸ” Comparison of Approaches:

Method	â±ï¸ Time Complexity	ğŸ§‘â€ğŸ’» Space Complexity	ğŸ“‹ Key Notes
Brute Force	O(n)	O(n)	âœ… Uses additional arrays for negative and positive numbers.
Efficient (Two Pointers)	O(n)	O(1)	âœ… In-place solution using two pointers with minimal extra space.
âœ¨ Key Takeaways:
Brute Force:

âœ… Simple to implement.

âŒ Uses extra space for two arrays.

Efficient (Two Pointers):

âœ… Space-efficient, works in-place.

âŒ Slightly more complex but optimal in terms of space.

